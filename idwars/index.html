<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åå­—ç«æŠ€åœº</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Roboto', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 2fr 3fr;
            grid-gap: 20px;
        }

        @media (max-width: 1100px) {
            .container {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        h1 {
            text-align: center;
            color: #fff;
            margin-bottom: 5px;
            font-size: 2.5rem;
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .subtitle {
            text-align: center;
            color: #a0a0a0;
            margin-bottom: 30px;
        }

        h2 {
            color: #fff;
            margin-bottom: 15px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 8px;
        }

        textarea {
            width: 100%;
            height: 200px;
            padding: 15px;
            border: none;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
            color: #fff;
            font-size: 16px;
            resize: vertical;
            margin-bottom: 15px;
            font-family: 'Roboto', monospace;
        }

        textarea:focus {
            outline: none;
            box-shadow: 0 0 0 2px #4d9fec;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            background: #4d9fec;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            flex: 1;
            min-width: 120px;
        }

        button:hover {
            background: #3a8bd8;
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        #startBtn {
            background: #4CAF50;
        }

        #startBtn:hover {
            background: #3d8b40;
        }

        #clearBtn {
            background: #f44336;
        }

        #clearBtn:hover {
            background: #d32f2f;
        }

        #exampleBtn {
            background: #FF9800;
        }

        #exampleBtn:hover {
            background: #e68900;
        }

        .speed-controls {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
        }

        .speed-btn {
            flex: 1;
            padding: 8px 5px;
            min-width: 60px;
        }

        .speed-btn.active {
            background: #2196F3;
            box-shadow: 0 0 0 2px white;
        }

        .battle-log {
            height: 500px; /* å¢åŠ æˆ˜æ–—æ—¥å¿—é«˜åº¦ */
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            font-family: 'Roboto', monospace;
        }

        .log-entry {
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .log-normal {
            color: #ddd;
        }

        .log-attack {
            color: #ff6b6b;
        }

        .log-critical {
            color: #ff9e2c;
            font-weight: bold;
        }

        .log-defend {
            color: #4ecdc4;
        }

        .log-heal {
            color: #1dd1a1;
        }

        .log-magic {
            color: #a29bfe;
        }

        .log-special {
            color: #ffeaa7;
            font-weight: bold;
        }

        .log-warning {
            color: #fdcb6e;
        }

        .log-death {
            color: #e17055;
            font-weight: bold;
        }

        .stats-panel {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 15px;
            max-height: 600px;
            overflow-y: auto;
            padding: 10px;
        }

        .character-card {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            transition: all 0.3s ease;
            border-left: 4px solid #4d9fec;
        }

        .character-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .character-name {
            font-weight: bold;
            font-size: 18px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .character-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 10px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
        }

        .hp-bar {
            height: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            overflow: hidden;
        }

        .hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            transition: width 0.5s ease;
        }

        .instructions {
            color: #bbb;
            margin-top: 20px;
            font-size: 14px;
            line-height: 1.5;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }

        .instructions h3 {
            color: #fff;
            margin-bottom: 10px;
        }

        .instructions ul {
            padding-left: 20px;
            margin-bottom: 10px;
        }

        .instructions li {
            margin-bottom: 5px;
        }

        .log-table {
            margin: 10px 0;
            border-radius: 5px;
            overflow: hidden;
        }

        .table-row {
            display: flex;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding: 5px 0;
        }

        .table-header {
            font-weight: bold;
            background: rgba(255, 255, 255, 0.1);
        }

        .table-cell {
            flex: 1;
            padding: 0 5px;
            text-align: center;
        }

        .table-cell:first-child {
            flex: 0.5;
        }

        .table-cell:nth-child(2) {
            flex: 2;
            text-align: left;
        }

        /* æ–°å¢ï¼šå³ä¾§é¢æ¿å¸ƒå±€è°ƒæ•´ */
        .right-panel {
            display: flex;
            flex-direction: column;
            height: 80%;
        }

        .stats-section {
            flex: 4; /* å æ®4/5ç©ºé—´ */
            display: flex;
            flex-direction: column;
            margin-bottom: 20px;
        }

        .stats-panel {
            flex: 2;
        }

        .instructions-section {
            flex: 1; /* å æ®1/5ç©ºé—´ */
        }
    </style>
</head>
<body>
    <h1>åå­—ç«æŠ€åœº v2.4.0</h1>
    <p class="subtitle">by std114514</p>
    
    <div class="container">
        <!-- å·¦ä¾§é¢æ¿ï¼šè¾“å…¥å’Œæˆ˜æ–—æ—¥å¿— -->
        <div class="panel">
            <h2>è¾“å…¥åå­—</h2>
            <textarea id="nameInput" placeholder="è¯·è¾“å…¥åå­—ï¼Œæ¯ä¸ªé˜Ÿä¼ç”¨ç©ºè¡Œåˆ†éš”"></textarea>
            
            <div class="button-group">
                <button id="startBtn">å¼€å§‹æˆ˜æ–—</button>
                <button id="clearBtn">æ¸…ç©º</button>
                <button id="exampleBtn">åŠ è½½ç¤ºä¾‹</button>
            </div>
            
            <h2>æˆ˜æ–—é€Ÿåº¦</h2>
            <div class="speed-controls">
                <button class="speed-btn" data-speed="500">æ…¢é€Ÿ</button>
                <button class="speed-btn active" data-speed="200">ä¸­é€Ÿ</button>
                <button class="speed-btn" data-speed="50">å¿«é€Ÿ</button>
                <button class="speed-btn" data-speed="10">æé€Ÿ</button>
            </div>
            
            <h2>æˆ˜æ–—æ—¥å¿—</h2>
            <div id="battleLog" class="battle-log"></div>
        </div>
        
        <!-- å³ä¾§é¢æ¿ï¼šè§’è‰²çŠ¶æ€å’Œè¯´æ˜ -->
        <div class="panel right-panel">
            <div class="stats-section">
                <h2>è§’è‰²çŠ¶æ€</h2>
                <div id="statsPanel" class="stats-panel">
                    <div style="text-align: center; color: #888; padding: 20px;">
                        æˆ˜æ–—å¼€å§‹åï¼Œè§’è‰²å±æ€§å°†æ˜¾ç¤ºåœ¨è¿™é‡Œ
                    </div>
                </div>
            </div>
            
            <div class="instructions-section">
                <div class="instructions">
                    <h3>æ¸¸æˆè¯´æ˜</h3>
                    <ul>
                        <li>æ¯ä¸ªé˜Ÿä¼ç”¨ç©ºè¡Œåˆ†éš”ï¼Œæ¯ä¸ªé˜Ÿä¼è‡³å°‘éœ€è¦1ä¸ªäºº</li>
                        <li>è‡³å°‘éœ€è¦2ä¸ªé˜Ÿä¼æ‰èƒ½å¼€å§‹æˆ˜æ–—</li>
                        <li>è§’è‰²çš„å±æ€§ç”±åå­—é€šè¿‡å“ˆå¸Œç®—æ³•è®¡ç®—å¾—å‡º</li>
                        <li>æˆ˜æ–—å®Œå…¨è‡ªåŠ¨è¿›è¡Œï¼Œç›´åˆ°åªå‰©ä¸€ä¸ªé˜Ÿä¼æˆ–å…¨éƒ¨é˜µäº¡</li>
                        <li>è¿å‡»è§„åˆ™ï¼šä¸åŒå›åˆé—´é€ æˆä¼¤å®³ä¸”è¿™ä¸¤ä¸ªå›åˆé—´æ²¡æœ‰æ‰è¡€æ‰ç®—è¿å‡»</li>
                    </ul>
                    <p>ğŸ’€ é˜µäº¡ | âš¡ è“„åŠ› | ğŸ”¥ ç‡ƒçƒ§ | ğŸ’– è¢«é­…æƒ‘</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        class NameArena {
            constructor() {
                this.characters = [];
                this.teams = [];
                this.battleLog = [];
                this.isFighting = false;
                this.currentSpeed = 200; // é»˜è®¤ä¸­ç­‰é€Ÿåº¦
                this.round = 0;
                
                this.initializeEventListeners();
            }
            
            initializeEventListeners() {
                document.getElementById('startBtn').addEventListener('click', () => this.startBattle());
                document.getElementById('clearBtn').addEventListener('click', () => this.clearInput());
                document.getElementById('exampleBtn').addEventListener('click', () => this.loadExample());
                
                // é€Ÿåº¦æ§åˆ¶
                document.querySelectorAll('.speed-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        this.currentSpeed = parseInt(e.target.dataset.speed);
                    });
                });
            }
            
            // å“ˆå¸Œå‡½æ•°1
            hash1(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    hash = (hash * 2337 + (str.charCodeAt(i) - 32) * 3868 + 1759) % 1000000;
                }
                return hash;
            }
            
            // å“ˆå¸Œå‡½æ•°2
            hash2(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    hash = (hash * 9571 + (str.charCodeAt(i) - 32) * 8683 + 7332) % 1000000;
                }
                return hash;
            }
            
            // é˜²å¾¡åˆ¤å®š
            defenseCheck(defense) {
                const rand = Math.floor(Math.random() * 150) + 1;
                if (rand <= defense / 4) return 2; // åå¼¹
                else if (rand <= defense) return 1; // é˜²å¾¡æˆåŠŸ
                else return 0; // é˜²å¾¡å¤±è´¥
            }
            
            // è§£æè¾“å…¥çš„åå­—
            parseNames(input) {
                const lines = input.split('\n');
                const teams = [];
                let currentTeam = [];
                
                lines.forEach(line => {
                    const trimmedLine = line.trim();
                    if (trimmedLine === '') {
                        if (currentTeam.length > 0) {
                            teams.push([...currentTeam]);
                            currentTeam = [];
                        }
                    } else {
                        currentTeam.push(trimmedLine);
                    }
                });
                
                if (currentTeam.length > 0) {
                    teams.push([...currentTeam]);
                }
                
                return teams;
            }

            // åˆå§‹åŒ–è§’è‰² - ä¿®å¤ç‰ˆæœ¬
            initializeCharacters(teams) {
                this.characters = [];
                let id = 1;
                
                teams.forEach((team, teamIndex) => {
                    team.forEach(name => {
                        const hash1 = this.hash1(name);
                        const hash2 = this.hash2(name);
                        
                        // å°†å“ˆå¸Œå€¼åˆ†è§£ä¸ºæ•°å­—æ•°ç»„
                        const x = [];
                        let temp = hash1;
                        for (let i = 0; i < 6; i++) {
                            x.push(temp % 10);
                            temp = Math.floor(temp / 10);
                        }
                        
                        const m = [];
                        temp = hash2;
                        for (let i = 0; i < 6; i++) {
                            m.push(temp % 10);
                            temp = Math.floor(temp / 10);
                        }
                        
                        // ä¿®å¤å±æ€§è®¡ç®— - ç¡®ä¿æ‰€æœ‰å€¼éƒ½æ˜¯æœ‰æ•ˆæ•°å­—
                        const maxHp = 350 + (x[0] || 0) * (x[3] || 0) + 2 * (x[2] || 0) * (x[5] || 0);
                        const attack = 15 + (x[1] || 0) + (x[4] || 0);
                        const critical = (5 + ((m[2] || 0) % 8)) * 5;
                        const defense = (5 + (m[4] || 0)) * 3;
                        const magic = (((m[0] || 0) % 6) + ((m[5] || 0) % 6) + ((m[1] || 0) % 6)) * 3;
                        
                        this.characters.push({
                            id: id++,
                            name: name,
                            team: teamIndex + 1,
                            maxHp: Math.max(1, maxHp),
                            currentHp: Math.max(1, maxHp),
                            attack: Math.max(1, attack),
                            critical: Math.max(1, critical),
                            defense: Math.max(1, defense),
                            magic: Math.max(1, magic),
                            isAlive: true,
                            isCharging: false,
                            isBurning: false,
                            burnDamage: 0,
                            isCriticalHealth: false,
                            isCharmed: false, // æ–°å¢ï¼šé­…æƒ‘çŠ¶æ€
                            charmedTurns: 0,  // æ–°å¢ï¼šé­…æƒ‘å‰©ä½™å›åˆæ•°
                            originalTeam: teamIndex + 1, // æ–°å¢ï¼šåŸå§‹é˜Ÿä¼
                            
                            // ç§¯åˆ†ç³»ç»Ÿ
                            score: 0,
                            totalDamage: 0,
                            defendSuccess: 0,
                            reboundSuccess: 0,
                            magicUsed: 0,
                            kills: 0,
                            killedBy: null, // ä¿®å¤ï¼šè®°å½•è¢«è°æ€æ­»
                            combo: 0,
                            lastComboRound: 0,
                            damagedRounds: [] // æ–°å¢ï¼šè®°å½•å—åˆ°ä¼¤å®³çš„å›åˆ
                        });
                    });
                });
            }
            
            // å¼€å§‹æˆ˜æ–—
            async startBattle() {
                const input = document.getElementById('nameInput').value.trim();
                if (!input) {
                    this.addLog('è¯·è¾“å…¥åå­—ï¼', 'log-warning');
                    return;
                }
                
                const teams = this.parseNames(input);
                
                if (teams.length < 2) {
                    this.addLog('è‡³å°‘éœ€è¦2ä¸ªé˜Ÿä¼ï¼', 'log-warning');
                    return;
                }
                
                const emptyTeams = teams.filter(team => team.length === 0);
                if (emptyTeams.length > 0) {
                    this.addLog('æ¯ä¸ªé˜Ÿä¼è‡³å°‘éœ€è¦1ä¸ªäººï¼', 'log-warning');
                    return;
                }
                
                this.isFighting = true;
                this.round = 0;
                this.battleLog = [];
                document.getElementById('battleLog').innerHTML = '';
                
                this.initializeCharacters(teams);
                this.displayCharacterStats();
                
                this.addLog('æˆ˜æ–—å¼€å§‹ï¼', 'log-special');
                await this.delay(1000);
                
                await this.fight();
            }
            
            // æˆ˜æ–—ä¸»å¾ªç¯
            async fight() {
                let lastAttacker = null;
                
                while (this.isFighting) {
                    this.round++;
                    
                    const aliveTeams = new Set();
                    this.characters.forEach(char => {
                        if (char.isAlive) {
                            aliveTeams.add(char.team);
                        }
                    });
                    
                    if (aliveTeams.size <= 1) {
                        this.endBattle();
                        break;
                    }
                    
                    let attacker = this.selectRandomAliveCharacter();
                    while (attacker === lastAttacker) {
                        attacker = this.selectRandomAliveCharacter();
                    }
                    lastAttacker = attacker;
                    
                    this.addLog(`ç¬¬ ${this.round} å›åˆ`, 'log-normal');
                    this.addLog(`ç°åœ¨æ˜¯ ${attacker.name} çš„å›åˆï¼`, 'log-special');
                    
                    await this.performAction(attacker);
                    await this.delay(this.currentSpeed);
                    
                    await this.processBurnDamage();
                    await this.delay(this.currentSpeed);
                    
                    this.checkCriticalHealth();
                    this.displayCharacterStats();
                    
                    await this.delay(this.currentSpeed);
                }
            }
            
            // é€‰æ‹©éšæœºå­˜æ´»çš„è§’è‰²
            selectRandomAliveCharacter() {
                const aliveChars = this.characters.filter(char => char.isAlive);
                return aliveChars[Math.floor(Math.random() * aliveChars.length)];
            }
            
            // æ‰§è¡Œè¡ŒåŠ¨ - ä¿®å¤ç‰ˆæœ¬ï¼ˆä¿®å¤é­…æƒ‘çŠ¶æ€è®¡æ•°ï¼‰
            async performAction(attacker) {
                // å¦‚æœæ­£åœ¨è“„åŠ›ï¼Œåˆ™å¼ºåˆ¶ä½¿ç”¨è“„åŠ›æ”»å‡»
                if (attacker.isCharging) {
                    await this.chargeAttack(attacker);
                    // è“„åŠ›æ”»å‡»åå‡å°‘é­…æƒ‘å›åˆæ•°
                    if (attacker.isCharmed) {
                        attacker.charmedTurns--;
                        if (attacker.charmedTurns <= 0) {
                            attacker.isCharmed = false;
                            attacker.team = attacker.originalTeam;
                            this.addLog(`${attacker.name} çš„é­…æƒ‘æ•ˆæœè§£é™¤äº†`, 'log-normal');
                        }
                    }
                    return;
                }
                
                const rand = Math.floor(Math.random() * 200) + 1;
                
                if (rand <= attacker.magic) {
                    await this.useMagic(attacker);
                } else if (rand <= attacker.magic + attacker.critical) {
                    await this.criticalAttack(attacker);
                } else {
                    await this.normalAttack(attacker);
                }
                
                // è¡ŒåŠ¨ç»“æŸåå‡å°‘é­…æƒ‘å›åˆæ•°
                if (attacker.isCharmed) {
                    attacker.charmedTurns--;
                    if (attacker.charmedTurns <= 0) {
                        attacker.isCharmed = false;
                        attacker.team = attacker.originalTeam;
                        this.addLog(`${attacker.name} çš„é­…æƒ‘æ•ˆæœè§£é™¤äº†`, 'log-normal');
                    }
                }
            }
            
            // æ™®é€šæ”»å‡»
            async normalAttack(attacker) {
                const target = this.selectRandomEnemy(attacker);
                if (!target) return;
                
                const damage = attacker.attack - 3 + Math.floor(Math.random() * 7);
                
                this.addLog(`${attacker.name} æ”»å‡» ${target.name}ï¼Œé€ æˆ ${damage} ç‚¹ä¼¤å®³`, 'log-attack');
                
                await this.applyDamage(attacker, target, damage);
            }
            
            // æš´å‡»æ”»å‡»
            async criticalAttack(attacker) {
                const target = this.selectRandomEnemy(attacker);
                if (!target) return;
                
                const damage = Math.floor(attacker.attack * 2.5) - 3 + Math.floor(Math.random() * 7);
                
                this.addLog(`${attacker.name} æš´å‡»ï¼å¯¹ ${target.name} é€ æˆ ${damage} ç‚¹ä¼¤å®³`, 'log-critical');
                
                await this.applyDamage(attacker, target, damage);
            }
            
            // ä½¿ç”¨é­”æ³•
            async useMagic(attacker) {
                const magicType = Math.floor(Math.random() * 10); // æ”¹ä¸º0-9ï¼Œå¢åŠ é­…æƒ‘æŠ€èƒ½
                
                // è®°å½•é­”æ³•ä½¿ç”¨
                attacker.magicUsed++;
                attacker.score += 40;
                this.addLog(`${attacker.name} ä½¿ç”¨é­”æ³•ï¼Œè·å¾— 40 åˆ†`, 'log-normal');
                
                switch (magicType) {
                    case 0:
                        await this.healMagic(attacker);
                        break;
                    case 1:
                        await this.heavyStrike(attacker);
                        break;
                    case 2:
                        await this.freezeMagic(attacker);
                        break;
                    case 3:
                        await this.buffMagic(attacker);
                        break;
                    case 4:
                        await this.nukeMagic(attacker);
                        break;
                    case 5:
                        await this.thunderMagic(attacker);
                        break;
                    case 6:
                        await this.chargeAttack(attacker);
                        break;
                    case 7:
                        await this.fireballMagic(attacker);
                        break;
                    case 8:
                        await this.resurrectMagic(attacker);
                        break;
                    case 9:
                        await this.charmMagic(attacker); // æ–°å¢ï¼šé­…æƒ‘é­”æ³•
                        break;
                }
            }
            
            // æ²»ç–—é­”æ³•
            async healMagic(attacker) {
                const ally = this.selectRandomAlly(attacker);
                const heal = Math.floor(ally.maxHp / 5) - 3 + Math.floor(Math.random() * 7);
                
                ally.currentHp = Math.min(ally.maxHp, ally.currentHp + heal);
                this.addLog(`${attacker.name} æ²»ç–— ${ally.name}ï¼Œå›å¤ ${heal} ç‚¹ HP`, 'log-heal');
            }
            
            // é‡åˆ›é­”æ³•
            async heavyStrike(attacker) {
                const target = this.selectRandomEnemy(attacker);
                if (!target) return;
                
                const damage = attacker.attack * 5 - 3 + Math.floor(Math.random() * 7);
                
                this.addLog(`${attacker.name} é‡åˆ› ${target.name}ï¼Œé€ æˆ ${damage} ç‚¹ä¼¤å®³ï¼`, 'log-attack');
                
                await this.applyDamage(attacker, target, damage);
            }
            
            // å†°å†»æœ¯
            async freezeMagic(attacker) {
                const target = this.selectRandomEnemy(attacker);
                if (!target) return;
                
                target.attack = Math.floor(target.attack * 0.67);
                target.defense = Math.floor(target.defense * 0.67);
                target.magic = Math.floor(target.magic * 0.67);
                
                this.addLog(`${attacker.name} ä½¿ç”¨å†°å†»æœ¯ï¼Œ${target.name} å±æ€§å…¨é¢é™ä½ï¼`, 'log-magic');
            }
            
            // å±æ€§æå‡
            async buffMagic(attacker) {
                attacker.attack = Math.floor(attacker.attack * 1.5);
                attacker.defense = Math.min(120, Math.floor(attacker.defense * 1.5));
                attacker.magic = Math.min(80, Math.floor(attacker.magic * 1.5));
                
                this.addLog(`${attacker.name} å±æ€§å…¨é¢æå‡ï¼`, 'log-magic');
            }
            
            // åŸå­å¼¹
            async nukeMagic(attacker) {
                const target = this.selectRandomEnemy(attacker);
                if (!target) return;
                
                const damage = Math.floor(target.currentHp / 2);
                const actualDamage = Math.min(target.currentHp, damage);
                target.currentHp -= actualDamage;
                
                this.addLog(`${attacker.name} æ‰”å‡ºåŸå­å¼¹ï¼Œ${target.name} çš„ HP å‡å°‘ä¸€åŠï¼`, 'log-special');
                
                // è®°å½•å—åˆ°ä¼¤å®³çš„å›åˆ
                this.recordDamagedRound(target);
                
                // è®°å½•ä¼¤å®³ - åŸå­å¼¹åº”è¯¥è®¡å…¥è¿å‡»
                this.recordDamage(attacker, target, actualDamage);
                
                if (target.isCharging) {
                    target.isCharging = false;
                    this.addLog(`${target.name} çš„è“„åŠ›è¢«æ‰“æ–­äº†ï¼`, 'log-warning');
                }
                
                this.checkDeath(target, attacker);
            }
            
            // é›·åŠˆæœ¯ - ä¿®æ”¹ç‰ˆï¼šä¸è®¡å…¥è¿å‡»
            async thunderMagic(attacker) {
                const damage = Math.floor(attacker.attack * 0.67) - 3 + Math.floor(Math.random() * 7);
                
                this.addLog(`${attacker.name} ä½¿ç”¨é›·åŠˆæœ¯ï¼Œå¯¹æ‰€æœ‰æ•Œäººé€ æˆ ${damage} ç‚¹ä¼¤å®³ï¼`, 'log-magic');
                
                // é›·åŠˆæœ¯ä¸è®¡å…¥è¿å‡»ï¼Œç›´æ¥è®°å½•ä¼¤å®³è€Œä¸è°ƒç”¨recordDamage
                this.characters.forEach(char => {
                    if (char.isAlive && char.team !== attacker.team) {
                        const actualDamage = Math.min(char.currentHp, damage);
                        char.currentHp -= actualDamage;
                        
                        // è®°å½•å—åˆ°ä¼¤å®³çš„å›åˆ
                        this.recordDamagedRound(char);
                        
                        // ç›´æ¥å¢åŠ ç§¯åˆ†ï¼Œä¸è§¦å‘è¿å‡»
                        attacker.score += actualDamage;
                        attacker.totalDamage += actualDamage;
                        
                        this.addLog(`é›·åŠˆæœ¯å¯¹ ${char.name} é€ æˆ ${actualDamage} ç‚¹ä¼¤å®³ï¼Œè·å¾— ${actualDamage} åˆ†`, 'log-normal');
                        
                        if (char.isCharging) {
                            char.isCharging = false;
                            this.addLog(`${char.name} çš„è“„åŠ›è¢«æ‰“æ–­äº†ï¼`, 'log-warning');
                        }
                        this.checkDeath(char, attacker);
                    }
                });
            }
            
            // è“„åŠ›æ”»å‡»
            async chargeAttack(attacker) {
                if (!attacker.isCharging) {
                    attacker.isCharging = true;
                    this.addLog(`${attacker.name} æ­£åœ¨è“„åŠ›...`, 'log-special');
                } else {
                    attacker.isCharging = false;
                    const target = this.selectRandomEnemy(attacker);
                    if (!target) return;
                    
                    const damage = attacker.attack * 24 - 3 + Math.floor(Math.random() * 7);
                    const actualDamage = Math.min(target.currentHp, damage);
                    
                    this.addLog(`${attacker.name} è“„åŠ›å®Œæˆï¼Œæ‰“å‡ºäº†ä¼šå¿ƒä¸€å‡»ï¼Œå¯¹ ${target.name} é€ æˆ ${actualDamage} ç‚¹æ— æ³•æŠµæŒ¡çš„ä¼¤å®³ï¼ï¼`, 'log-critical');
                    
                    // ç›´æ¥åº”ç”¨ä¼¤å®³ï¼Œå› ä¸ºè“„åŠ›æ”»å‡»æ— æ³•è¢«é˜²å¾¡
                    target.currentHp -= actualDamage;
                    
                    // è®°å½•å—åˆ°ä¼¤å®³çš„å›åˆ
                    this.recordDamagedRound(target);
                    
                    this.recordDamage(attacker, target, actualDamage);
                    
                    if (target.isCharging) {
                        target.isCharging = false;
                        this.addLog(`${target.name} çš„è“„åŠ›è¢«æ‰“æ–­äº†ï¼`, 'log-warning');
                    }
                    this.checkDeath(target, attacker);
                }
            }
            
            // ç«çƒæœ¯
            async fireballMagic(attacker) {
                const target = this.selectRandomEnemy(attacker);
                if (!target) return;
                
                const damage = Math.floor(attacker.attack * 3) - 3 + Math.floor(Math.random() * 7);
                
                target.isBurning = true;
                target.burnDamage = damage;
                
                this.addLog(`${attacker.name} å¯¹ ${target.name} æ‰”å‡ºç«çƒï¼Œé€ æˆ ${damage} ç‚¹ä¼¤å®³å¹¶ç‚¹ç‡ƒï¼`, 'log-attack');
                
                await this.applyDamage(attacker, target, damage);
                
                if (target.isCharging) {
                    target.isCharging = false;
                    this.addLog(`${target.name} çš„è“„åŠ›è¢«æ‰“æ–­äº†ï¼`, 'log-warning');
                }
            }
            
            // å¤æ´»é­”æ³•
            async resurrectMagic(attacker) {
                const deadAllies = this.characters.filter(char => 
                    !char.isAlive && char.team === attacker.team
                );
                
                if (deadAllies.length > 0) {
                    const target = deadAllies[Math.floor(Math.random() * deadAllies.length)];
                    target.isAlive = true;
                    target.currentHp = Math.floor(target.maxHp / 5);
                    target.isCharging = false;
                    target.isBurning = false;
                    target.burnDamage = 0;
                    target.isCriticalHealth = false; // æ¸…é™¤æ¿’æ­»çŠ¶æ€
                    target.isCharmed = false; // æ¸…é™¤é­…æƒ‘çŠ¶æ€
                    target.charmedTurns = 0;
                    target.team = target.originalTeam; // æ¢å¤åŸå§‹é˜Ÿä¼
                    target.killedBy = null; // æ¸…é™¤æ­»äº¡è®°å½•
                    target.combo = 0;
                    target.lastComboRound = 0;
                    target.damagedRounds = []; // é‡ç½®ä¼¤å®³è®°å½•
                    
                    // é‡ç½®å±æ€§åˆ°åˆå§‹å€¼ï¼ˆé¿å…æ¿’æ­»çŠ¶æ€çš„å½±å“ï¼‰
                    this.resetCharacterStats(target);
                    
                    this.addLog(`${attacker.name} å¤æ´»äº† ${target.name}ï¼`, 'log-heal');
                } else {
                    this.addLog(`${attacker.name} è¯•å›¾å¤æ´»é˜Ÿå‹ï¼Œä½†æ²¡æœ‰ç›®æ ‡`, 'log-warning');
                }
            }
            
            // ä¿®æ”¹åçš„é­…æƒ‘é­”æ³• - æ·»åŠ é˜Ÿä¼äººæ•°æ£€æŸ¥
            async charmMagic(attacker) {
                const target = this.selectRandomEnemy(attacker);
                if (!target) return;
                
                // æ£€æŸ¥ç›®æ ‡åŸå§‹é˜Ÿä¼ä¸­å­˜æ´»çš„äººæ•°
                const aliveInTargetTeam = this.characters.filter(char => 
                    char.isAlive && char.originalTeam === target.originalTeam
                ).length;
                
                // å¦‚æœç›®æ ‡é˜Ÿä¼åªæœ‰ä¸€äººï¼Œé­…æƒ‘å¤±è´¥
                if (aliveInTargetTeam <= 1) {
                    this.addLog(`${attacker.name} è¯•å›¾é­…æƒ‘ ${target.name}ï¼Œä½† ${target.name} çš„é˜Ÿä¼åªå‰©ä¸€äººï¼Œé­…æƒ‘å¤±è´¥ï¼`, 'log-warning');
                    return;
                }
                
                target.isCharmed = true;
                target.charmedTurns = 2; // æŒç»­2å›åˆ
                target.team = attacker.team; // æš‚æ—¶åŠ å…¥æ”»å‡»è€…çš„é˜Ÿä¼
                    
                this.addLog(`${attacker.name} ä½¿ç”¨é­…æƒ‘æœ¯ï¼Œ${target.name} è¢«é­…æƒ‘äº†ï¼æ¥ä¸‹æ¥çš„2å›åˆå°†æ”»å‡»é˜Ÿå‹`, 'log-magic');
            }
            
            // åº”ç”¨ä¼¤å®³ - ä¿®æ”¹ç‰ˆï¼ŒåŒ…å«ç§¯åˆ†è®¡ç®—å’Œåå¼¹æˆåŠŸåˆ¤å®š
            async applyDamage(attacker, target, damage) {
                const defenseResult = this.defenseCheck(target.defense);
                
                switch (defenseResult) {
                    case 1: // é˜²å¾¡æˆåŠŸ
                        this.addLog(`${target.name} é˜²å¾¡æˆåŠŸ`, 'log-defend');
                        target.defendSuccess++;
                        target.score += 20;
                        this.addLog(`${target.name} é˜²å¾¡æˆåŠŸï¼Œè·å¾— 20 åˆ†`, 'log-normal');
                        break;
                        
                    case 2: // åå¼¹
                        this.addLog(`${target.name} åå¼¹ä¼¤å®³`, 'log-defend');
                        
                        const reboundResult = this.defenseCheck(attacker.defense);
                        
                        if (reboundResult === 2) {
                            this.addLog(`${attacker.name} å†æ¬¡åå¼¹`, 'log-defend');
                            attacker.reboundSuccess++;
                            attacker.score += 90;
                            this.addLog(`${attacker.name} å†æ¬¡åå¼¹ï¼Œè·å¾— 90 åˆ†`, 'log-normal');
                            
                            // åå¼¹ç»™åŸç›®æ ‡
                            const actualDamage = Math.min(target.currentHp, damage);
                            target.currentHp -= actualDamage;
                            
                            // è®°å½•ç›®æ ‡å—åˆ°ä¼¤å®³çš„å›åˆ
                            this.recordDamagedRound(target);
                            this.recordDamage(attacker, target, actualDamage);
                            
                            if (target.isCharging) {
                                target.isCharging = false;
                                this.addLog(`${target.name} çš„è“„åŠ›è¢«æ‰“æ–­äº†ï¼`, 'log-warning');
                            }
                        } else if (reboundResult === 1) {
                            this.addLog(`${attacker.name} é˜²å¾¡æˆåŠŸ`, 'log-defend');
                            attacker.defendSuccess++;
                            attacker.score += 20;
                            this.addLog(`${attacker.name} é˜²å¾¡æˆåŠŸï¼Œè·å¾— 20 åˆ†`, 'log-normal');
                        } else {
                            // åå¼¹æˆåŠŸ - åªæœ‰åœ¨è¿™ç§æƒ…å†µä¸‹æ‰ç®—çœŸæ­£çš„åå¼¹æˆåŠŸ
                            target.reboundSuccess++;
                            target.score += 90;
                            this.addLog(`${target.name} åå¼¹æˆåŠŸï¼Œè·å¾— 90 åˆ†`, 'log-normal');
                            
                            // åå¼¹ç»™æ”»å‡»è€…
                            const actualDamage = Math.min(attacker.currentHp, damage);
                            attacker.currentHp -= actualDamage;
                            
                            // è®°å½•æ”»å‡»è€…å—åˆ°ä¼¤å®³çš„å›åˆ
                            this.recordDamagedRound(attacker);
                            this.recordDamage(target, attacker, actualDamage);
                        }
                        break;
                        
                    default: // é˜²å¾¡å¤±è´¥
                        const actualDamage = Math.min(target.currentHp, damage);
                        target.currentHp -= actualDamage;
                        
                        // è®°å½•ç›®æ ‡å—åˆ°ä¼¤å®³çš„å›åˆ
                        this.recordDamagedRound(target);
                        this.recordDamage(attacker, target, actualDamage);
                        
                        if (target.isCharging) {
                            target.isCharging = false;
                            this.addLog(`${target.name} çš„è“„åŠ›è¢«æ‰“æ–­äº†ï¼`, 'log-warning');
                        }
                        break;
                }
                
                this.checkDeath(target, attacker);
                if (attacker.currentHp <= 0) {
                    this.checkDeath(attacker, target);
                }
            }
            
            // æ–°å¢æ–¹æ³•ï¼šè®°å½•è§’è‰²å—åˆ°ä¼¤å®³çš„å›åˆ
            recordDamagedRound(character) {
                if (!character.damagedRounds) {
                    character.damagedRounds = [];
                }
                character.damagedRounds.push(this.round);
            }
            
            // è®°å½•ä¼¤å®³å¹¶è®¡ç®—ç§¯åˆ† - ä¿®å¤ç‰ˆï¼šåŸºäºæ”»å‡»è€…æ˜¯å¦åœ¨å›åˆé—´å—åˆ°ä¼¤å®³
            recordDamage(attacker, target, actualDamage) {
                // æ£€æŸ¥æ”»å‡»è€…æ˜¯å¦åœ¨ä¸¤æ¬¡æ”»å‡»ä¹‹é—´å—åˆ°ä¼¤å®³
                let shouldResetCombo = false;
                
                if (attacker.lastComboRound > 0) {
                    // æ£€æŸ¥ä»ä¸Šæ¬¡æ”»å‡»åˆ°è¿™æ¬¡æ”»å‡»ä¹‹é—´ï¼Œæ”»å‡»è€…æ˜¯å¦å—åˆ°ä¼¤å®³
                    for (let round = attacker.lastComboRound + 1; round < this.round; round++) {
                        // å¦‚æœæœ‰ä»»ä½•ä¸€å›åˆæ”»å‡»è€…å—åˆ°äº†ä¼¤å®³ï¼Œé‡ç½®è¿å‡»
                        if (attacker.damagedRounds && attacker.damagedRounds.includes(round)) {
                            shouldResetCombo = true;
                            break;
                        }
                    }
                }
                
                // æ›´æ–°è¿å‡»
                if (attacker.lastComboRound > 0 && !shouldResetCombo && 
                    attacker.lastComboRound !== this.round) { // ç¡®ä¿ä¸æ˜¯åŒä¸€å›åˆ
                    attacker.combo++;
                } else {
                    attacker.combo = 1;
                }
                attacker.lastComboRound = this.round;
                
                // è®¡ç®—åŸºç¡€ç§¯åˆ†
                let damageScore = actualDamage;
                
                // è¿å‡»åŠ æˆ
                if (attacker.combo > 1) {
                    damageScore = Math.floor(damageScore * Math.pow(1.4, attacker.combo - 1));
                }
                
                // æ›´æ–°ç§¯åˆ†å’Œä¼¤å®³ç»Ÿè®¡
                attacker.score += damageScore;
                attacker.totalDamage += actualDamage;
                
                this.addLog(`${attacker.name} é€ æˆ ${actualDamage} ç‚¹ä¼¤å®³ï¼Œè·å¾— ${damageScore} åˆ†${attacker.combo > 1 ? ` (è¿å‡»x${attacker.combo})` : ''}`, 'log-normal');
            }
            
            // å¤„ç†ç‡ƒçƒ§ä¼¤å®³ - ä¿®å¤ç‰ˆæœ¬
            async processBurnDamage() {
                this.characters.forEach(char => {
                    if (char.isAlive && char.isBurning && char.burnDamage > 0) {
                        // è®¡ç®—å½“å‰å›åˆçš„ç‡ƒçƒ§ä¼¤å®³
                        const burnDmg = Math.floor(char.burnDamage * 0.4);
                        
                        if (burnDmg > 0) {
                            const actualDamage = Math.min(char.currentHp, burnDmg);
                            char.currentHp -= actualDamage;
                            
                            // è®°å½•å—åˆ°ä¼¤å®³çš„å›åˆ
                            this.recordDamagedRound(char);
                            
                            // ç‡ƒçƒ§ä¼¤å®³ä¸è®¡å…¥è¿å‡»ï¼Œä½†è®¡å…¥ç§¯åˆ†
                            char.score += actualDamage;
                            char.totalDamage += actualDamage;
                            
                            this.addLog(`${char.name} å—åˆ° ${actualDamage} ç‚¹ç‡ƒçƒ§ä¼¤å®³`, 'log-attack');
                            this.checkDeath(char);
                            
                            // æ›´æ–°ç‡ƒçƒ§ä¼¤å®³ä¸ºä¸‹ä¸€å›åˆçš„å€¼ï¼ˆä¹˜ä»¥0.4å¹¶å‘ä¸‹å–æ•´ï¼‰
                            char.burnDamage = Math.floor(char.burnDamage * 0.4);
                            
                            // å¦‚æœä¸‹ä¸€å›åˆçš„ç‡ƒçƒ§ä¼¤å®³ä¸º0ï¼Œæ¸…é™¤ç‡ƒçƒ§çŠ¶æ€
                            if (char.burnDamage <= 0) {
                                char.isBurning = false;
                                char.burnDamage = 0;
                                this.addLog(`${char.name} çš„ç‡ƒçƒ§æ•ˆæœæ¶ˆå¤±äº†`, 'log-normal');
                            }
                        } else {
                            // å¦‚æœå½“å‰ç‡ƒçƒ§ä¼¤å®³ä¸º0ï¼Œæ¸…é™¤ç‡ƒçƒ§çŠ¶æ€
                            char.isBurning = false;
                            char.burnDamage = 0;
                            this.addLog(`${char.name} çš„ç‡ƒçƒ§æ•ˆæœæ¶ˆå¤±äº†`, 'log-normal');
                        }
                    }
                });
            }

            // æ£€æŸ¥æ¿’æ­»çŠ¶æ€
            checkCriticalHealth() {
                this.characters.forEach(char => {
                    if (char.isAlive && !char.isCriticalHealth && 
                        char.currentHp <= char.maxHp * 0.1) {
                        char.isCriticalHealth = true;
                        char.attack *= 2;
                        char.defense = Math.min(120, char.defense * 2);
                        char.magic = Math.min(80, char.magic * 2);
                        this.addLog(`${char.name} è¿›å…¥æ¿’æ­»çŠ¶æ€ï¼Œå±æ€§å¤§å¹…æå‡ï¼`, 'log-special');
                    }
                });
            }
            
            // æ£€æŸ¥æ­»äº¡ - ä¿®æ”¹ç‰ˆï¼ŒåŒ…å«å‡»æ€ç§¯åˆ†
            checkDeath(character, killer = null) {
                if (character.currentHp <= 0 && character.isAlive) {
                    character.isAlive = false;
                    character.currentHp = 0;
                    character.isCharging = false;
                    character.isBurning = false;
                    character.isCharmed = false;
                    character.charmedTurns = 0;
                    character.team = character.originalTeam; // æ¢å¤åŸå§‹é˜Ÿä¼
                    
                    if (killer) {
                        // è®°å½•å‡»æ€
                        killer.kills++;
                        killer.score += 200;
                        character.killedBy = killer.name; // ä¿®å¤ï¼šè®°å½•è°æ€æ­»äº†è¿™ä¸ªè§’è‰²
                        this.addLog(`${character.name} è¢« ${killer.name} å‡»æ€ï¼${killer.name} è·å¾— 200 åˆ†`, 'log-death');
                    } else {
                        this.addLog(`${character.name} é˜µäº¡`, 'log-death');
                    }
                }
            }
            
            // ç»“æŸæˆ˜æ–— - ä¿®æ”¹ç‰ˆï¼Œæ˜¾ç¤ºMVPå’Œæ’è¡Œæ¦œ
            endBattle() {
                this.isFighting = false;
                
                const winningTeam = new Set();
                this.characters.forEach(char => {
                    if (char.isAlive) {
                        winningTeam.add(char.originalTeam); // ä½¿ç”¨åŸå§‹é˜Ÿä¼åˆ¤æ–­èƒœåˆ©
                    }
                });
                
                if (winningTeam.size === 0) {
                    this.addLog('å…¨å†›è¦†æ²¡ï¼', 'log-death');
                } else {
                    const teamNumber = Array.from(winningTeam)[0];
                    const winners = this.characters.filter(char => 
                        char.isAlive && char.originalTeam === teamNumber
                    );
                    
                    this.addLog('æˆ˜æ–—ç»“æŸï¼', 'log-special');
                    this.addLog(`ç¬¬ ${teamNumber} é˜Ÿå–å¾—äº†èƒœåˆ©ï¼`, 'log-special');
                    this.addLog('èƒœåˆ©è€…ï¼š' + winners.map(w => w.name).join('ã€'), 'log-special');
                }
                
                // æ˜¾ç¤ºMVPå’Œæ’è¡Œæ¦œ
                this.showRankings();
            }
            
            // ä½¿ç”¨HTMLè¡¨æ ¼çš„ç‰ˆæœ¬
            showRankings() {
                const logContainer = document.getElementById('battleLog');
                
                // MVPæ˜¾ç¤º
                this.addLog('', 'log-normal');
                this.addLog('=== æœ¬åœºMVP ===', 'log-special');
                
                const rankedCharacters = [...this.characters].sort((a, b) => b.score - a.score);
                if (rankedCharacters.length > 0) {
                    const mvp = rankedCharacters[0];
                    this.addLog(`ğŸ† ${mvp.name} - ${mvp.score}åˆ†`, 'log-special');
                }
                
                // ç§¯åˆ†æ’è¡Œæ¦œè¡¨æ ¼
                this.addLog('', 'log-normal');
                this.addLog('=== ç§¯åˆ†æ’è¡Œæ¦œ ===', 'log-special');
                
                const scoreTable = document.createElement('div');
                scoreTable.className = 'log-table';
                scoreTable.innerHTML = `
                    <div class="table-row table-header">
                        <div class="table-cell">æ’å</div>
                        <div class="table-cell">ID</div>
                        <div class="table-cell">ç§¯åˆ†</div>
                        <div class="table-cell">æœ€åä¸€å‡»</div>
                    </div>
                `;
                
                rankedCharacters.forEach((char, index) => {
                    const row = document.createElement('div');
                    row.className = 'table-row';
                    const status = char.killedBy ? `${char.killedBy}` : 'å­˜æ´»';
                    row.innerHTML = `
                        <div class="table-cell">${index + 1}</div>
                        <div class="table-cell">${char.name}</div>
                        <div class="table-cell">${char.score}</div>
                        <div class="table-cell">${status}</div>
                    `;
                    scoreTable.appendChild(row);
                });
                
                logContainer.appendChild(scoreTable);
            }
            
            // æ–°å¢ï¼šé‡ç½®è§’è‰²å±æ€§åˆ°åˆå§‹å€¼
            resetCharacterStats(character) {
                const hash1 = this.hash1(character.name);
                const hash2 = this.hash2(character.name);
                
                const x = [];
                let temp = hash1;
                for (let i = 0; i < 6; i++) {
                    x.push(temp % 10);
                    temp = Math.floor(temp / 10);
                }
                
                const m = [];
                temp = hash2;
                for (let i = 0; i < 6; i++) {
                    m.push(temp % 10);
                    temp = Math.floor(temp / 10);
                }
                
                // é‡æ–°è®¡ç®—åŸºç¡€å±æ€§
                character.maxHp = 350 + (x[0] || 0) * (x[3] || 0) + 2 * (x[2] || 0) * (x[5] || 0);
                character.attack = 15 + (x[1] || 0) + (x[4] || 0);
                character.critical = (5 + ((m[2] || 0) % 8)) * 5;
                character.defense = (5 + (m[4] || 0)) * 3;
                character.magic = (((m[0] || 0) % 6) + ((m[5] || 0) % 6) + ((m[1] || 0) % 6)) * 3;
                
                // ç¡®ä¿å±æ€§è‡³å°‘ä¸º1
                character.maxHp = Math.max(1, character.maxHp);
                character.attack = Math.max(1, character.attack);
                character.critical = Math.max(1, character.critical);
                character.defense = Math.max(1, character.defense);
                character.magic = Math.max(1, character.magic);
                
                // é‡ç½®æ¿’æ­»çŠ¶æ€
                character.isCriticalHealth = false;
            }
            
            // é€‰æ‹©éšæœºæ•Œäºº - ä¿®æ”¹ç‰ˆï¼šè€ƒè™‘é­…æƒ‘çŠ¶æ€
            selectRandomEnemy(attacker) {
                let enemies;
                
                if (attacker.isCharmed) {
                    // å¦‚æœè¢«é­…æƒ‘ï¼Œå°†é˜Ÿå‹è§†ä¸ºæ•Œäºº
                    enemies = this.characters.filter(char => 
                        char.isAlive && char.team === attacker.originalTeam && char.id !== attacker.id
                    );
                } else {
                    // æ­£å¸¸æƒ…å†µï¼šé€‰æ‹©ä¸åŒé˜Ÿä¼çš„æ•Œäºº
                    enemies = this.characters.filter(char => 
                        char.isAlive && char.team !== attacker.team
                    );
                }
                
                return enemies.length > 0 ? enemies[Math.floor(Math.random() * enemies.length)] : null;
            }
            
            // é€‰æ‹©éšæœºé˜Ÿå‹ - ä¿®æ”¹ç‰ˆï¼šè€ƒè™‘é­…æƒ‘çŠ¶æ€
            selectRandomAlly(attacker) {
                let allies;
                
                if (attacker.isCharmed) {
                    // å¦‚æœè¢«é­…æƒ‘ï¼Œå°†æ•Œäººè§†ä¸ºé˜Ÿå‹
                    allies = this.characters.filter(char => 
                        char.isAlive && char.team !== attacker.originalTeam && char.id !== attacker.id
                    );
                } else {
                    // æ­£å¸¸æƒ…å†µï¼šé€‰æ‹©åŒé˜Ÿä¼çš„é˜Ÿå‹
                    allies = this.characters.filter(char => 
                        char.isAlive && char.team === attacker.team && char.id !== attacker.id
                    );
                }
                
                return allies.length > 0 ? 
                    allies[Math.floor(Math.random() * allies.length)] : attacker;
            }
            
            // æ·»åŠ æ—¥å¿—
            addLog(message, className = 'log-normal') {
                const logEntry = document.createElement('div');
                logEntry.className = `log-entry ${className}`;
                logEntry.textContent = message;
                
                const logContainer = document.getElementById('battleLog');
                logContainer.appendChild(logEntry);
                logContainer.scrollTop = logContainer.scrollHeight;
                
                this.battleLog.push({ message, className });
            }
            
            // æ˜¾ç¤ºè§’è‰²çŠ¶æ€
            displayCharacterStats() {
                const statsPanel = document.getElementById('statsPanel');
                statsPanel.innerHTML = '';
                
                this.characters.forEach(char => {
                    const card = document.createElement('div');
                    card.className = 'character-card';
                    
                    const hpPercent = Math.max(0, (char.currentHp / char.maxHp) * 100);
                    const teamColor = this.getTeamColor(char.originalTeam); // ä½¿ç”¨åŸå§‹é˜Ÿä¼é¢œè‰²
                    
                    let statusIcons = '';
                    if (!char.isAlive) statusIcons += 'ğŸ’€';
                    if (char.isCharging) statusIcons += 'âš¡';
                    if (char.isBurning) statusIcons += 'ğŸ”¥';
                    if (char.isCharmed) statusIcons += 'ğŸ’–';
                    
                    card.innerHTML = `
                        <div class="character-name" style="color: ${teamColor}">
                            ${char.name} ${statusIcons}
                        </div>
                        <div class="character-stats">
                            <div class="stat-item">
                                <span>HP:</span>
                                <span>${char.currentHp}/${char.maxHp}</span>
                            </div>
                            <div class="stat-item">
                                <span>æ”»å‡»:</span>
                                <span>${char.attack}</span>
                            </div>
                            <div class="stat-item">
                                <span>æš´å‡»:</span>
                                <span>${char.critical}</span>
                            </div>
                            <div class="stat-item">
                                <span>é˜²å¾¡:</span>
                                <span>${char.defense}</span>
                            </div>
                            <div class="stat-item">
                                <span>é­”æ³•:</span>
                                <span>${char.magic}</span>
                            </div>
                            <div class="stat-item">
                                <span>ç§¯åˆ†:</span>
                                <span>${char.score}</span>
                            </div>
                            <div class="stat-item">
                                <span>è¿å‡»:</span>
                                <span>${char.combo}</span>
                            </div>
                            <div class="stat-item">
                                <span>é˜Ÿä¼:</span>
                                <span>${char.originalTeam}${char.isCharmed ? '(è¢«é­…æƒ‘)' : ''}</span>
                            </div>
                        </div>
                        <div class="hp-bar">
                            <div class="hp-fill" style="width: ${hpPercent}%"></div>
                        </div>
                    `;
                    
                    statsPanel.appendChild(card);
                });
            }
            
            // è·å–é˜Ÿä¼é¢œè‰² - çœŸæ­£éšæœºç‰ˆæœ¬
            getTeamColor(team) {
                // ç”Ÿæˆé²œè‰³çš„éšæœºé¢œè‰²
                const hue = (team * 137.5) % 360; // ä½¿ç”¨é»„é‡‘è§’åº¦æ¥è·å¾—å‡åŒ€åˆ†å¸ƒçš„é¢œè‰²
                const saturation = 70 + Math.random() * 20; // 70-90% é¥±å’Œåº¦
                const lightness = 50 + Math.random() * 10; // 50-60% äº®åº¦
                
                return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
            }
            
            // æ¸…ç©ºè¾“å…¥
            clearInput() {
                document.getElementById('nameInput').value = '';
                document.getElementById('battleLog').innerHTML = '';
                document.getElementById('statsPanel').innerHTML = 
                    '<div style="text-align: center; color: #888; padding: 20px;">æˆ˜æ–—å¼€å§‹åï¼Œè§’è‰²å±æ€§å°†æ˜¾ç¤ºåœ¨è¿™é‡Œ</div>';
                this.isFighting = false;
            }
            
            // åŠ è½½ç¤ºä¾‹
            loadExample() {
                const example = `å¼ ä¸‰
æå››
ç‹äº”

91
78
13

ChatGPT
DeepSeek
DouBaoAI

ThisTeamHa_sOnly1Person`;
                document.getElementById('nameInput').value = example;
            }
            
            // å»¶è¿Ÿå‡½æ•°
            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // åˆå§‹åŒ–åå­—ç«æŠ€åœº
        document.addEventListener('DOMContentLoaded', () => {
            new NameArena();
        });
    </script>
</body>
</html>
